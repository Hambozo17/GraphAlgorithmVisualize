import { AlgorithmInfo } from '../types';

export const algorithmInfo: Record<string, AlgorithmInfo> = {
  bfs: {
    name: 'Breadth-First Search (BFS)',
    description: 'Explores all vertices at the present depth before moving on to vertices at the next depth level. Ideal for finding the shortest path in unweighted graphs.',
    timeComplexity: {
      best: 'O(V + E)',
      average: 'O(V + E)',
      worst: 'O(V + E)',
    },
    spaceComplexity: 'O(V)',
    useCases: [
      'Finding shortest path in unweighted graphs',
      'Level-order traversal',
      'Finding connected components',
      'Testing bipartiteness',
    ],
    pseudocode: [
      'BFS(G, start):',
      '  queue ← [start]',
      '  visited ← {start}',
      '  while queue is not empty:',
      '    u ← queue.dequeue()',
      '    for each neighbor v of u:',
      '      if v not in visited:',
      '        visited.add(v)',
      '        queue.enqueue(v)',
    ],
    supportsWeighted: false,
    supportsNegative: false,
    findsShortestPath: true,
  },
  dfs: {
    name: 'Depth-First Search (DFS)',
    description: 'Explores as far as possible along each branch before backtracking. Useful for detecting cycles and topological sorting.',
    timeComplexity: {
      best: 'O(V + E)',
      average: 'O(V + E)',
      worst: 'O(V + E)',
    },
    spaceComplexity: 'O(V)',
    useCases: [
      'Cycle detection',
      'Topological sorting',
      'Finding strongly connected components',
      'Maze solving',
      'Path finding (not necessarily shortest)',
    ],
    pseudocode: [
      'DFS(G, start):',
      '  stack ← [start]',
      '  visited ← {}',
      '  while stack is not empty:',
      '    u ← stack.pop()',
      '    if u not in visited:',
      '      visited.add(u)',
      '      for each neighbor v of u:',
      '        stack.push(v)',
    ],
    supportsWeighted: false,
    supportsNegative: false,
    findsShortestPath: false,
  },
  dijkstra: {
    name: "Dijkstra's Algorithm",
    description: 'Finds the shortest path from a source vertex to all other vertices in a weighted graph with non-negative edge weights.',
    timeComplexity: {
      best: 'O((V + E) log V)',
      average: 'O((V + E) log V)',
      worst: 'O(V²)',
    },
    spaceComplexity: 'O(V)',
    useCases: [
      'GPS navigation systems',
      'Network routing protocols',
      'Shortest path in road networks',
      'Social network analysis',
    ],
    pseudocode: [
      "Dijkstra(G, start):",
      '  dist[v] ← ∞ for all v',
      '  dist[start] ← 0',
      '  Q ← priority queue with all vertices',
      '  while Q is not empty:',
      '    u ← vertex with min dist in Q',
      '    remove u from Q',
      '    for each neighbor v of u:',
      '      alt ← dist[u] + weight(u, v)',
      '      if alt < dist[v]:',
      '        dist[v] ← alt',
      '        prev[v] ← u',
    ],
    supportsWeighted: true,
    supportsNegative: false,
    findsShortestPath: true,
  },
  'bellman-ford': {
    name: 'Bellman-Ford Algorithm',
    description: 'Computes shortest paths from a source vertex to all vertices. Unlike Dijkstra, it can handle negative edge weights and detect negative cycles.',
    timeComplexity: {
      best: 'O(E)',
      average: 'O(V × E)',
      worst: 'O(V × E)',
    },
    spaceComplexity: 'O(V)',
    useCases: [
      'Graphs with negative edge weights',
      'Currency exchange arbitrage detection',
      'Distance-vector routing protocols',
      'Constraint satisfaction problems',
    ],
    pseudocode: [
      'BellmanFord(G, start):',
      '  dist[v] ← ∞ for all v',
      '  dist[start] ← 0',
      '  repeat |V| - 1 times:',
      '    for each edge (u, v) with weight w:',
      '      if dist[u] + w < dist[v]:',
      '        dist[v] ← dist[u] + w',
      '  // Check for negative cycles',
      '  for each edge (u, v) with weight w:',
      '    if dist[u] + w < dist[v]:',
      '      return "Negative cycle exists"',
    ],
    supportsWeighted: true,
    supportsNegative: true,
    findsShortestPath: true,
  },
  astar: {
    name: 'A* Algorithm',
    description: 'An informed search algorithm that uses heuristics to find the shortest path more efficiently than Dijkstra in many cases.',
    timeComplexity: {
      best: 'O(E)',
      average: 'O(E)',
      worst: 'O(V²)',
    },
    spaceComplexity: 'O(V)',
    useCases: [
      'Video game pathfinding',
      'Robot navigation',
      'Route planning',
      'Puzzle solving (e.g., 8-puzzle)',
    ],
    pseudocode: [
      'A*(G, start, goal):',
      '  openSet ← {start}',
      '  gScore[v] ← ∞ for all v',
      '  gScore[start] ← 0',
      '  fScore[start] ← h(start)',
      '  while openSet is not empty:',
      '    current ← node with lowest fScore',
      '    if current = goal:',
      '      return reconstructPath()',
      '    remove current from openSet',
      '    for each neighbor of current:',
      '      tentative_g ← gScore[current] + d(current, neighbor)',
      '      if tentative_g < gScore[neighbor]:',
      '        update scores and path',
    ],
    supportsWeighted: true,
    supportsNegative: false,
    findsShortestPath: true,
  },
};
